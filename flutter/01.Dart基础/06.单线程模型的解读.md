#### 目录介绍
- 01.先思考一个问题
- 02.理解单线程和异步
- 03.单线程如何异步
- 04.Dart异步任务
- 05.Future异步任务
- 06.异步函数的实现




### 01.先思考一个问题
- 与原生 Android 和 iOS 的多线程机制相比，单线程的 Dart 如何从语言设计层面和代码运行机制上保证 Flutter UI 的流畅性呢？



### 02.理解单线程和异步
- 需要建立这样一个概念，那就是 Dart 是单线程的。那单线程意味着什么呢？这意味着 Dart 代码是有序的，按照在 main 函数出现的次序一个接一个地执行，不会被其他代码中断。
- 另外，作为支持 Flutter 这个 UI 框架的关键技术，Dart 当然也支持异步。需要注意的是，单线程和异步并不冲突。


### 03.单线程如何异步
- 有一个大前提，那就是我们的 App 绝大多数时间都在等待。
    - 比如，等用户点击、等网络请求返回、等文件 IO 结果，等等。而这些等待行为并不是阻塞的。
    - 比如说，网络请求，Socket 本身提供了 select 模型可以异步查询；而文件 IO，操作系统也提供了基于事件的回调机制。
- 单线程模型可以在等待的过程中做别的事情，等真正需要响应结果了，再去做对应的处理。
    - 因为等待过程并不是阻塞的，所以给我们的感觉就像是同时在做多件事情一样。但其实始终只有一个线程在处理你的事情。
- 如何处理等待的这个行为？
    - 等待这个行为是通过 Event Loop 驱动的。事件队列 Event Queue 会把其他平行世界（比如 Socket）完成的，需要主线程响应的事件放入其中。
    - 像其他语言一样，Dart 也有一个巨大的事件循环，在不断的轮询事件队列，取出事件（比如，键盘事件、I\O 事件、网络事件等），在主线程同步执行其回调函数
    - ![image](https://static001.geekbang.org/resource/image/0c/ec/0cb6e6d34295cef460e48d139bc944ec.png)


### 04.Dart异步任务
- 在 Dart 中，实际上有两个队列
    - 一个事件队列（Event Queue），另一个则是微任务队列（Microtask Queue）。
    - 在每一次事件循环中，Dart 总是先去第一个微任务队列中查询是否有可执行的任务，如果没有，才会处理后续的事件队列的流程。
- Event Loop 完整版的流程图，应该如下所示：
    - ![image](https://static001.geekbang.org/resource/image/70/bc/70dc4e1c222ddfaee8aa06df85c22bbc.png)
- 微任务队列Microtask Queue
    - 微任务顾名思义，表示一个短时间内就会完成的异步任务。
    - 从上面的流程图可以看到，微任务队列在事件循环中的优先级是最高的，只要队列中还有任务，就可以一直霸占着事件循环。
    - 微任务是由 scheduleMicroTask 建立的。
    - 一般的异步任务通常也很少必须要在事件队列前完成，所以也不需要太高的优先级，因此我们通常很少会直接用到微任务队列，就连 Flutter 内部，也只有 7 处用到了而已（比如，手势识别、文本输入、滚动视图、保存页面效果等需要高优执行任务的场景）。
- 事件队列Event Queue
    - 比如，I/O、绘制、定时器这些异步事件，都是通过事件队列驱动主线程执行的。
    - Dart 为 Event Queue 的任务建立提供了一层封装，叫作 Future。从名字上也很容易理解，它表示一个在未来时间才会完成的任务。
    - 把一个函数体放入 Future，就完成了从同步任务到异步任务的包装。Future 还提供了链式调用的能力，可以在异步任务执行完毕后依次执行链路上的其他函数体。


### 05.Future异步任务
- 一个 Future 异步任务的执行是相对简单的
    - 在我们声明一个 Future 时，Dart 会将异步任务的函数执行体放入事件队列，然后立即返回，后续的代码继续同步执行。
    - 而当同步执行的代码执行完毕后，事件队列会按照加入事件队列的顺序（即声明顺序），依次取出事件，最后同步执行 Future 的函数体及后续的 then。
    - 这意味着，then 与 Future 函数体共用一个事件循环。而如果 Future 有多个 then，它们也会按照链式调用的先后顺序同步执行，同样也会共用一个事件循环。
- 你只需要记住一点：
    - then 会在 Future 函数体执行完毕后立刻执行，无论是共用同一个事件循环还是进入下一个微任务。


### 06.异步函数的实现
- 对于一个异步函数来说，其返回时内部执行动作并未结束，因此需要返回一个 Future 对象，供调用者使用。
    - 调用者根据 Future 对象，来决定：是在这个 Future 对象上注册一个 then，等 Future 的执行体结束了以后再进行异步处理；还是一直同步等待 Future 执行体结束。
    - 对于异步函数返回的 Future 对象，如果调用者决定同步等待，则需要在调用处使用 await 关键字，并且在调用处的函数体使用 async 关键字。
- 看一个案例
    ``` dart
    //声明了一个延迟3秒返回Hello的Future，并注册了一个then返回拼接后的Hello 2019
    Future<String> fetchContent() => 
      Future<String>.delayed(Duration(seconds:3), () => "Hello")
        .then((x) => "$x 2019");
    
      main() async{
        print(await fetchContent());//等待Hello 2019的返回
      }
    ```
- await 和 async 是配对使用的
    - 因为 Dart 中的 await 并不是阻塞等待，而是异步等待。
    - Dart 会将调用体的函数也视作异步函数，将等待语句的上下文放入 Event Queue 中，一旦有了结果，Event Loop 就会把它从 Event Queue 中取出，等待代码继续执行。









