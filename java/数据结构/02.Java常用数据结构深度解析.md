### 目录介绍
- 1.对象数组
- 2.集合
	* 2.1 集合的由来
	* 2.2 数组和集合的区别
	* 2.3 集合继承体系图
	* 2.4 Collection功能概述
	* 2.5 集合的遍历
	* 2.6 迭代器的原理
- 3.数据结构
	* 3.0 List集合如何选择合适的
	* 3.1 数据结构之数组和链表
	* 3.2 数据结构之栈和队列
- 4.集合总结
	* 4.1 集合总结
	* 4.2 Hashcode与equal区别



#### 0.总结
- **1. List**
    - ArrayList：基于动态数组实现，支持随机访问。
    - Vector：和 ArrayList 类似，但它是线程安全的。
    - LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。
- **2. Set**
    - TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
    - HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
    - LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。
- **3.Map**
    - TreeMap：基于红黑树实现。
    - HashMap：基于哈希表实现。
    - HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
    - LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
- **4. Queue**
    - LinkedList：可以用它来实现双向队列。
    - PriorityQueue：基于堆结构实现，可以用它来实现优先队列。


#### 1.对象数组
- **1.1 绘制对象数组内存图**
    * 需求：把三个学生的信息【姓名，年龄】存储到对象数组中
    * 绘制内场图如下所示：
![image](https://upload-images.jianshu.io/upload_images/4432347-5a919e36b6d89254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 2.集合
- **2.1 集合的由来**
	* 面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，Java就提供了集合类。


- **2.2 数组和集合的区别**
	* (1): 长度区别: 数组的长度是固定的而集合的长度是可变的
	* (2): 存储数据类型的区别: 数组可以存储基本数据类型 , 也可以存储引用数据类型; 而集合只能存储引用数据类型
	* (3): 内容区别: 数组只能存储同种数据类型的元素 ,集合可以存储不同类型的元素


- **2.3 集合继承体系图**
![image](https://upload-images.jianshu.io/upload_images/4432347-492ac09cb88c5b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


- **2.4 Collection功能概述**
- a:添加功能
	* boolean add(Object obj):添加一个元素
	* boolean addAll(Collection c):添加一个集合的元素
- b:删除功能
	* void clear():移除所有元素
	* boolean remove(Object o):移除一个元素
	* boolean removeAll(Collection c):移除一个集合的元素(是一个还是所有)
- c:判断功能
	* boolean contains(Object o)：判断集合中是否包含指定的元素   
	* boolean containsAll(Collection c)：判断集合中是否包含指定的集合元素(是一个还是所有)
	* boolean isEmpty()：判断集合是否为空
- d:获取功能
	* Iterator<E> iterator()(重点)
- e:长度功能
	* int size():元素的个数
	* 面试题：数组有没有length()方法呢?字符串有没有length()方法呢?集合有没有length()方法呢?
- f:交集功能
	* boolean retainAll(Collection c):两个集合都有的元素?思考元素去哪了，返回的boolean又是什么意思呢?
- g:把集合转换为数组
	* Object[] toArray()


- **2.5 集合的遍历**
- 2.5.1 迭代器遍历【用的较少】

```
public class CollectionDemo {
    public static void main(String[] args) {
        // Iterator iterator():     使用迭代器进行遍历(重点*********)
        // 创建Collection集合对象
        Collection col = new ArrayList() ;
        // 添加元素
        col.add("张三") ;
        col.add("李四") ;
        col.add("王五") ;
        col.add("赵六") ;
        // 使用迭代器对其进行遍历
        // 1. 获取迭代器对象
        Iterator it = col.iterator() ;   // 返回时实现了Iterator这个接口的子类对象
        // 2. 调用迭代器对象中的方法完成遍历
        // E next(): 获取元素的同时,将指针向后移动一位
        while(it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
```

- 2.5.2 集合转数组遍历

```
public class CollectionDemo {
    public static void main(String[] args) {
        // 1. 创建集合对象
        Collection col = new ArrayList() ;
        // 2. 添加元素
        col.add("鸣人") ;
        col.add("佐助") ;
        col.add("佩恩") ;
        // 3. 把集合转换成数组
        // Object[] toArray()
        Object[] objs = col.toArray() ;
        // 4. 遍历数组
        for(int x = 0 ; x < objs.length ; x++) {
            // 向下转型
            String s = (String)objs[x] ;
            System.out.println(s.length());
        }
    }
}
```

- 2.6 迭代器的原理
![image](https://upload-images.jianshu.io/upload_images/4432347-a371a7eb3e355bd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 3.数据结构
- **3.0 List集合如何选择合适的**
![image](https://note.youdao.com/yws/public/resource/d19b6297f596bc8891f92d529cf0a889/xmlnote/A3A14CD7CA2F4CFABF4A1055325D9B58/9148)


- **3.1 数据结构之数组和链表**
![image](https://note.youdao.com/yws/public/resource/d19b6297f596bc8891f92d529cf0a889/xmlnote/246A6E391DC942B2B618F3B7EBD6E5AC/9155)


- **3.2 数据结构之栈和队列**
![image](https://note.youdao.com/yws/public/resource/d19b6297f596bc8891f92d529cf0a889/xmlnote/CFE081526C054FD497D34F24C4D90A8F/9162)


#### 4.集合总结
- **4.1 集合总结**
![image](https://upload-images.jianshu.io/upload_images/4432347-760b4c34becd66c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


- **4.2 Hashcode与equal区别**
    - 同样用于鉴定2个对象是否相等的，java集合中有 list 和 set 两类，其中 set不允许元素重复实现，那个这个不允许重复实现的方法，如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次 equal 去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上


### 关于其他内容介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- 我的个人站点：www.yczbj.org，www.ycbjie.cn
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yang-chong-69-24/pins/posts
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles

