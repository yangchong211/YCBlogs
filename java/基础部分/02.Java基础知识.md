### 目录结构
- 注意：红色字体为未答出的知识点
- 0.Java语言概述
- 1.Java标识符规则【规则，注意事项，命名规范】
- 2.常量和变量【区别，常量种类】
- 3.进制【种类，转换，补码反码】
- 4.Java数据类型【种类，转换规则，注意要点】
- 5.字符编码【种类】
- 6.运算符【种类，区别】
- 7.Java基本语句结构【种类，区别说明】
- 8.方法【定义，格式】
- 9.数组【一维数组，二维数组】
- 10.内存分配以及栈和堆的
- 11.使用switch和if-else区别



#### 0.Java语言概述
- **0.1 jdk工具部分exe解释**
    * jar.exe       jar包
    * javadoc.exe   文档生成器
    * Java.exe      解释器
    * Javac.exe     编辑器


- **0.2 开发与运行Java程序需经过哪些过程？**
    * 用工具编辑源程序，也就是写代码，保存
    * 用Java编辑器工具javac.exe编译源程序文件，生成字节码.class文件
    * 用Java解释器工具Java.exe解释运行生成.class文件

- **0.3 Java是如何实现跨平台的？**
    * 如下所示：
```
跨平台是怎样实现的呢？这就要谈及Java虚拟机（Java Virtual Machine，简称 JVM）。

JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。

而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。

JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。

注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。

所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。

注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。
```


#### 1.Java标识符规则
- **1.1 组成规则**
	* 英文大小写字母
	* 数字字符
	* $或_
- **1.2 注意事项**
	* 不能以数字开头
	* 不能是Java中的关键字
	* 区分大小写
	* 不能有空格
- **1.3 命名规范【必须见名知意】**
	* 下划线式命名：my_name
	* 驼峰式命名：myName
	* 类，接口命名：必须是大写字母开头，比如PersonActivity
	* 方法，变量【字符串】命名：getData()，otherName
	* 常量命名：一般全是大写，比如MAX_VALUE


#### 2.常量和变量
- **2.1 什么是常量和变量**
	* 其值不可以改变的称之为常量
	* 其值会发生变化的称之为变量
- **2.2 常量有哪些**
	* 字符串常量     用双引号包括的     "hello world"
	* 整型常量         所有的整数     199
	* 小数常量         所有的小数     4.50
	* 字符常量         用单引号包括的     'a'
	* 布尔常量         true和false    
	* 空常量            null
- **2.3 变量**
	* 用来描述值可以变化的量，比如室外温度，App活跃用户量等



#### 3.进制
- **3.1 进制有哪些**
- 二进制
	* 0和1     前缀0B或者0b       比如：0B1001      转为十进制是9
- 八进制
	* 0-7       前缀0       比如：0103       
- 十进制【我们常用的】
	* 0-9       没有前缀
- 十六进制
	* 0-9 和 A-F     前缀0x或者0X          比如：0x123
- 进制转化
	* 任何进制转化为十进制公式：系数 * 底数 ^ 指数

```
0b1010 = 1 * 2^3 + 0 *2^2 + 1*2^1 + 0*2^0
       = 8 + 0 + 2 + 0
       = 10

0123  = 1*8^2 + 2*8^1 + 3*8^0
      = 64 + 16 + 3
      = 83

0x123 = 1*16^2 + 2*16^1 + 3*16^0
      = 256 + 32 + 3
      = 291
```

- **3.2 补码**
	* 正数的补码和原码相同

```
5
原码：0000 0101
补码：0000 0101
	* 负数的补码是它的反码加1

-5：
原码：1000 0101
反码：1111 1010
    +         1
------------------
补码  1111 1011
```


#### 4.Java数据类型
- **4.1 数据类型有哪些**
- byte类型
	* 1个字节，8位【-128到127之间】
- short类型
	* 2个字节，16位【-2^15 到 2^15 -1】
- int类型
	* 4个字节，32位【-2^31 到 2^31 -1】
- float类型【浮点型】
	* 4个字节，32位
- double类型【浮点型】
	* 8个字节，64位
- long类型
	* 8个字节，64位【-2^63  到 2^63 -1】
- char类型
	* 2个字节，16位【1个汉字刚好2个字节】
- boolean类型
	* 1个字节，true和false


- **4.2 数据的转换**
- 默认转换
	* 1：byte,short,char—int—long—float—double
	* 2：byte,short,char相互之间补转换，他们参与运算首先转换为int类型
- 强制转换
	* 格式: 目标类型 变量名 = (目标类型)值或变量名
	* int a = (int) 15.7f;
- 注意要点
```
!!!!!!!注意!!!!!!!!
1:在java中，任何一个整数默认为 int 类型 (1)
2:在java种，任何一个小数，默认为 double 类型( 1.0)
3:123L 或者 1231 编译器会将该数当成long类型
4:12.345f 或者12.345F 编译器会将该数当成float类型
```


#### 5.字符编码
- 常见的字符编码
	* ASCII码
	* GBK码
	* Unicode码【占2个字节】


#### 6.运算符
- **6.1 运算符有哪些？**
	* 算术运算符
	* 赋值运算符
	* 关系运算符
	* 逻辑运算符
	* 三目运算符
	* 特殊运算符：位运算符
- **6.2 算术运算符**
	* + ，- ， * ， / ， %【取余】 ， ++【自加】， --【自减】
- **6.3 赋值运算符**
	* = ， += ， -= ， *= ， /= ， %= 
- **6.4 关系运算符**
	* == ， > , < , >= , <= , !=
- **6.5 逻辑运算符**
	* & ，^ ，| ，&& ，|| ，！ ， ^
- **6.6 三目运算符【Android中用的很多】**
	*  a == b ？ c ： d
	* 格式：(条件表达式)？表达式1：表达式2
- **6.7 位运算符**
	* & , |   ,  ^ ,  ~  ,  <<  ,  >>  ,  >>>


#### 7.Java基本语句结构
- **7.1 语句结构种类**
	* 顺序结构
	* 选择结构
	* 循环结构
- **7.2 顺序结构**
	* 从上到下依次执行
- **7.3 选择结构【可以嵌套】**
	* if  ，  if  else  ， if  else if …… else
	* switch case【支持byte，short，char，int，String】
- **7.4 循环结构**
- for
```
for(初始化语句;判断条件语句;控制条件语句) {
         循环体语句;
}
第一步：先执行初始化语句，只执行一次
第二步：执行判断条件语句
第三部：执行循环体语句
第四步：执行控制条件语句，然后再执行循环体语句【循环】
```

- while
```
初始化语句;
while(判断条件语句) {
    循环体语句;
    控制条件语句;
}
```

- do while
```
do {
         循环体语句;
}while((判断条件语句);
```


#### 8.Java方法
- **8.1 定义**
- 方法就是完成特定功能的代码块
	* 1：系统方法，只需要会使用，不需要知道内部的结构
	* 2：自定义方法：方法的内部实现需要我们来写
	* 3：方法内部不能再嵌套方法


- **8.2 格式**
- 方法格式
```
修饰符   返回值类型   方法名(参数类型 参数 , ……){
     函数体
     return 返回值
}
```

- 修饰符: public static或直接是public或是其它private
- 返回类型:所有的数据类型（基本类型：int ,char ,float, long, 引用类型:String）
- 方法名：1:见名知意 2: getMax
- 参数类型:所有的数据类型 ，如果一个方法没有返回值，则返回值类型为void
- 参数名:变量名
- 返回值：就是要返回的结果（这个结果必须和返回类型一致）


#### 9.数组
- **9.1 数组概念**
	* 数组是一个容器，可以存储多个变量，这些变量数据类型要一致
	* 数组既可以存储基本数据类型，也可以存储引用数据类型


- **9.2 一维数组**
- 数组定义格式
	* 格式1：数据类型【】 数组名
	* 格式2：数据类型   数组名【】
```
int[] a；     定义了一个int类型的数组a；
int a[];    定义了一个int类型的a数组；
推荐使用第一种定义方式。
```

- 数组的初始化
	* Java中的数组必须先初始化,然后才能使用。
	* 所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。


- 初始化分类：
	* a:动态初始化:   只指定长度，由系统给出初始化值
	* b:静态初始化:    给出初始化值，由系统决定长度
	* 注意事项：这两种方式，只能使用一种，不能进行动静结合   


- **9.3 二维数组**
- 数组定义格式
    * 数据类型[][] 变量名 = new 数据类型[m][n];
	* m表示这个二维数组有多少个一维数组
	* n表示每一个一维数组的元素个数


- 举例:

```
int[][] arr = new int[3][2];
定义了一个二维数组arr
这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]
每个一维数组有2个元素，可以通过arr[m][n]来获取,表示获取第m+1个一维数组的第n+1个元素
```


#### 10.Java的内存分配以及栈和堆的区别
- **10.1 先了解几个概念**
	* 栈
	* 堆
	* 方法区
	* 本地方法去
	* 寄存器

```
A:栈: 存放的是局部变量
局部变量：在方法定义或者方法声明上的变量都是局部变量。
B:堆: 存放的是所有new出来的东西
特点：
    a: 每一个new出来的东西都会为其分配一个地制值。
    b: 每一个变量都有一个默认的值
        byte，short，int，long  -- 0
        float，double            -- 0.0
        char                    -- '\u0000'
        boolean                -- false
        引用数据类型               -- null       
    c: 使用完毕就变成了垃圾，等待垃圾回收器对其回收
C:方法区:(面向对象部分讲解)
D:本地方法区:(和系统相关)
E:寄存器:(cpu使用)
```


#### 11.使用switch和if-else区别
- **11.1 switch语句特点**
- 使用switch语句时，要注意表达式必须是符合byte，char，short，int或枚举类型的表达式，而不能使用浮点类型或long类型。
- switch语句将表达式的值依次与每个case子语句中的常量值相比较。如果匹配成功，则执行该case语句中的语句，直到遇到break语句为止。
- default语句是可选的，当表达式的值与任何一个case语句都不匹配时，就执行default后的语句。



- **11.2 switch语句与if-else比较**
- if-else只是单纯地一个接一个比较；if...else每个条件都计算一遍；
- 使用了Binary，Tree算法；绝大部分情况下switch会快一点，除非是if-else的第一个条件就为true。编译器编译switch与编译if...else...不同。不管有多少case，都直接跳转，不需逐个比较查询；switch只计算一次值，然后都是test , jmp……有很多else if的时候，用switch case比较清晰
- switch...case与if...else，if的根本区别在于，switch...case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch...case不用像if...else那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。


### 关于其他内容介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- 我的个人站点：www.yczbj.org，www.ycbjie.cn
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yang-chong-69-24/pins/posts
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
