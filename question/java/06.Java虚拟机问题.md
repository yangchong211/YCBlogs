#### 目录介绍
- 6.0.0.1 运行时数据区域有哪些？Java虚拟机栈是做什么的？本地方法栈又是做什么的？
- 6.0.0.2 对象的内存布局？对象的访问定位方式有哪些？使用指针访问和使用句柄访问各具有何优势？
- 6.0.0.3 说一下对象的创建过程？变量创建过程种放在虚拟机哪里？变量[区别静态变量]什么时候回收？
- 6.0.0.4 OutOfMemoryError异常在哪些数据区域中可能会出现？分别说一下这个数据区域出现OOM的场景和缘由？
- 6.0.0.6 Java中堆和栈的区别？分别写出堆内存溢出与栈内存溢出的程序？以及如何解决溢出代码方案？
- 6.0.0.7 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
- 6.0.0.8 java中垃圾收集的方法有哪些？如何实现检测垃圾？引用计数法有什么不足，说下看法？
- 6.0.1.1 如和判断一个对象是否存活?引用计数法和可达性算法哪个更加好？如何理解一个对象不一定会被回收？
- 6.0.1.2 Class.forName() 和ClassLoader.loadClass()区别？实际开发你用那种，为什么？
- 6.0.1.3 Java对象的访问定位方式有哪些？这些访问方式各有何利弊？如何理解通过句柄访问方式？
- 6.0.1.4 内存回收主要是针对那块？如何判断对象是否死亡？如何判断一个常量是废弃常量？如何判断一个类是无用的类？




### 好消息
- 博客笔记大汇总【15年10月到至今】，包括Java基础及深入知识点，Android技术博客，Python学习笔记等等，还包括平时开发中遇到的bug汇总，当然也在工作之余收集了大量的面试题，长期更新维护并且修正，持续完善……开源的文件是markdown格式的！同时也开源了生活博客，从12年起，积累共计500篇[近100万字]，将会陆续发表到网上，转载请注明出处，谢谢！
- **链接地址：https://github.com/yangchong211/YCBlogs**
- 如果觉得好，可以star一下，谢谢！当然也欢迎提出建议，万事起于忽微，量变引起质变！**所有博客将陆续开源到GitHub！**




#### 6.0.0.1 运行时数据区域有哪些？Java虚拟机栈是做什么的？本地方法栈又是做什么的？
- 运行时数据区域有哪些？
    - Java虚拟机管理的内存包括几个运行时数据内存：方法区、虚拟机栈、本地方法栈、堆、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区
    - 1.1 程序计数器
        - 程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域
    - 1.2 Java虚拟机栈
        - 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
        - [技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - 栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分
        - 局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）
        - 其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。
        - Java虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常
    - 1.3 本地方法栈
        - 本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务
        - 本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常
    - 1.4 Java堆
        - 堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都在堆上分配
        - Java堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代
        - 不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存
        - Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常
    - 1.5 方法区
        - 方法区它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
        - 除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载
        - 当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常
    - 1.6 运行时常量池
        - 它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放
        - Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法
        - 当常量池无法再申请到内存时会抛出OutOfMemoryError异常



#### 6.0.0.2 对象的内存布局？对象的访问定位方式有哪些？使用指针访问和使用句柄访问各具有何优势？
- 对象的内存布局？
    - 在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：对象头、实例数据和对齐填充
    - 对象头包括两部分：
        - a) 储存对象自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
        - b) 另一部分是指类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例
- 对象的访问定位方式有哪些？
    - 使用句柄访问
        - Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址
    - 使用直接指针访问
        - Java堆对象的布局就必须考虑如何访问类型数据的相关信息,而refreence中存储的直接就是对象的地址
- 使用指针访问和使用句柄访问各具有何优势？
    - 使用句柄访问优势:reference中存储的是稳点的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改
    - 使用直接指针访问优势：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本
    - [技术博客大总结](https://github.com/yangchong211/YCBlogs)


#### 6.0.0.3 说一下对象的创建过程？变量创建过程种放在虚拟机哪里？
- 说一下对象的创建过程？比如：Dog dog= new Dog()；
    - 当虚拟机执行到new指令时，它先在常量池中查找“Dog”，看能否定位到Dog类的符号引用；如果能，说明这个类已经被加载到方法区了，则继续执行。如果没有，就让Class Loader先执行类的加载。
    - 然后，虚拟机开始为该对象分配内存，对象所需要的内存大小在类加载完成后就已经确定了。这时候只要在堆中按需求分配空间即可。具体分配内存时有两种方式，第一种，内存绝对规整，那么只要在被占用内存和空闲内存间放置指针即可，每次分配空间时只要把指针向空闲内存空间移动相应距离即可，当某对象被GC回收后，则需要进行某些对象内存的迁移。第二种，空闲内存和非空闲内存夹杂在一起，那么就需要用一个列表来记录堆内存的使用情况，然后按需分配内存。
    - 对于多线程的情况，如何确保一个线程分配了对象内存但尚未修改内存管理指针时，其他线程又分配该块内存而覆盖的情况？有一种方法，就是让每一个线程在堆中先预分配一小块内存（TLAB本地线程分配缓冲），每个线程只在自己的内存中分配内存。但对象本身按其访问属性是可以线程共享访问的。
    - 内存分配到后，虚拟机将分配的内存空间都初始化为零值(不包括对象头)。实例变量按变量类型初始化相应的默认值（数值型为0，boolan为false），所以实例变量不赋初值也能使用。接着设置对象头信息，比如对象的哈希值，GC分代年龄等。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 从虚拟机角度，此时一个新的对象已经创建完成了。但从我们程序运行的角度，新建对象才刚刚开始，对象的构造方法还没有执行。只有执行完构造方法，按构造方法进行初始化后，对象才是彻底创建完成了。构造函数的执行还涉及到调用父类构造器，如果没有显式声明调用父类构造器，则自动添加默认构造器。
    - new运算符可以返回堆中这个对象的引用
- 变量创建过程种放在虚拟机哪里？
    - 变量是实例变量、局部变量或静态变量的不同将引用放在不同的地方：
        - 如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。
        - 如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。
        - 如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。


#### 6.0.0.4 OutOfMemoryError异常在哪些数据区域中可能会出现？分别说一下这个数据区域出现OOM的场景和缘由？
- OutOfMemoryError异常在哪些数据区域中可能会出现？
    - Java堆溢出
    - 虚拟机栈和本地方法栈溢出
    - 方法区和运行时常量池溢出
- 分别说一下这个数据区域出现OOM的场景和缘由？
    - Java堆溢出
        - Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常
        - 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置
        - 如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗
    - 虚拟机栈和本地方法栈溢出
        - 对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：
        - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError
        - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常
        - 在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常
        - 如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程
    - 方法区和运行时常量池溢出
        - String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用
        - 由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - Intern():JDK1.6 intern方法会把首次遇到的字符串实例复制到永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用。JDK1.7 intern()方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个



#### 6.0.0.6 Java中堆和栈的区别？分别写出堆内存溢出与栈内存溢出的程序？以及如何解决溢出代码方案？
- Java中堆和栈的区别？
    - 栈内存：主要用来存放基本数据类型和局部变量；当在代码块定义一个变量时会在栈中为这个变量分配内存空间，当超过变量的作用域后这块空间就会被自动释放掉。
    - 堆内存：用来存放运行时创建的对象，比如通过new关键字创建出来的对象和数组；需要由Java虚拟机的自动垃圾回收器来管理。
- 分别写出堆内存溢出与栈内存溢出的程序？
    - 栈内存溢出
    ```
    public void A() {
        A();
    }
    ```
    - 堆内存溢出
    ```
    public void testd() {
        List<String> list = new ArrayList<>();
        int i = 0;
        while (true) {
            list.add(new String(i + ""));
            i++;
        }
    }
    ```



#### 6.0.0.7 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
- 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
    - 不会，在下一个垃圾回收周期中，这个对象将是可被回收的。
    - 也就是说当一个对象的引用变为null时，并不会被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。


#### 6.0.0.8 java中垃圾收集的方法有哪些？如何实现检测垃圾？引用计数法有什么不足，说下看法？
- java中垃圾收集的方法有哪些
    - 标记-清除:
        - 这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。
    - 复制算法:
        - 为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。
        - 于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)
    - 标记-整理[技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - 该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
    - 分代收集 
        - 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。


#### 6.0.1.0 Java对象的访问定位方式有哪些？这些对象访问方式各有优势？通过句柄访问方式是怎样的？通过直接指针访问方式？
- 01.Java对象的访问定位方式
    - 建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定
    - 目前主流的访问方式有
        - **①使用句柄**
        - **②直接指针**
- **这两种对象访问方式各有优势。**
    - 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
    - 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
- 通过句柄访问方式
    - 通过句柄访问方式
        - 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
        ![image](https://upload-images.jianshu.io/upload_images/4432347-5b5462dfa50f4e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 句柄是什么？
- 通过直接指针访问方式
    - 如果使用直接指针访问，那么 Java 堆对像的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
    ![image](https://upload-images.jianshu.io/upload_images/4432347-89ff06972fe7d216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 6.0.1.1 如和判断一个对象是否存活?引用计数法和可达性算法哪个更加好？如何理解一个对象不一定会被回收？
- 1. 引用计数法
    - 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
    - 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
- 2.可达性算法(引用链法)
    - 该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
    - 在java中可以作为GC Roots的对象有以下几种:
        - 虚拟机栈中引用的对象
        - 方法区类静态属性引用的对象
        - 方法区常量池引用的对象
        - 本地方法栈JNI引用的对象
- 如何理解一个对象不一定会被回收？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记
    - 如果对象在可达性分析中没有与GCRoot的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。
    - 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。


#### 6.0.1.2 Class.forName() 和ClassLoader.loadClass()区别？实际开发你用那种，为什么？
- Class.forName() 和ClassLoader.loadClass()区别？
    - 问到的是反射，但是在底层涉及到了虚拟机的类加载知识。
    - Class.forName() 默认执行类加载过程中的连接与初始化动作，一旦执行初始化动作，静态变量就会被初始化为程序员设置的值，如果有静态代码块，静态代码块也会被执行
    - ClassLoader.loadClass() 默认只执行类加载过程中的加载动作，后面的动作都不会执行



#### 6.0.1.3 Java对象的访问定位方式有哪些？这些访问方式各有何利弊？如何理解通过句柄访问方式？
- Java对象的访问定位方式
    - 建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定
    - 目前主流的访问方式有
    - **①使用句柄**
    - **②直接指针**
- **这两种对象访问方式各有优势。**
    - 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
    - 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
    - 区别：由于对象访问极其频繁，所以Hot Spot也使用第二种方式，直接存实例引用是效率比较高的。但是第一种句柄的方式，好处在于，垃圾回收中，不需要更改栈上所存储的地址，栈上的存储稳定，只需要修改句柄池。
- 如何理解通过句柄访问方式？
    - 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
    ![image](https://upload-images.jianshu.io/upload_images/4432347-5b5462dfa50f4e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 如何理解通过直接指针访问方式
    - 如果使用直接指针访问，那么 Java 堆对像的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
    ![image](https://upload-images.jianshu.io/upload_images/4432347-89ff06972fe7d216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




#### 6.0.1.4 内存回收主要是针对那块？如何判断对象是否死亡？如何判断一个常量是废弃常量？如何判断一个类是无用的类？
- 内存回收主要是针对那块？
    - Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。
- 如何判断对象是否死亡？
    - 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-2a2d50bb59c70459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 如何理解不可达的对象并非“非死不可”
    - 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。
    - 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。
- 如何判断一个常量是废弃常量
- 如何判断一个类是无用的类？
    - 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 **“无用的类”** ：
    - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    - 加载该类的 ClassLoader 已经被回收。
    - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    - 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。




### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- 我的个人站点：
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yang-chong-69-24/pins/posts
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e











